<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: WebRTC.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: WebRTC.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * WebRTC Object
 * @date 8/16/2023 - 3:17:59 PM
 *
 * @export
 * @class WebRTC
 * @typedef {WebRTC}
 */
export default class WebRTC {
    /**
     * Creates an instance of WebRTC.
     * @date 8/16/2023 - 3:10:11 PM
     *
     * @constructor
     */
    constructor() {
        let configuration = {};
        let dataChannel = null;
        let dataChannelCloseHandler, dataChannelErrorHandler;
        let dataChannelMessageHandler, dataChannelOpenHandler;
        let iceCandidateEventHandler, iceConnectionStateChangeHandler, iceGatheringStateChangeHandler;
        let isDebug = false, localStream = null;
        let negotiationHandler, peerConnection = null, peerConnectionStateChangeHandler;
        let signalingStateChangeHandler, trackEventHandler;
        /**
         * Add ICE Candidate to the Peer Connection
         * @date 8/16/2023 - 3:19:11 PM
         * @name WebRTC#addICECandidate
         * @async
         * @param {object} iceCandidate
         */        
        this.addICECandidate = async(iceCandidate) => {
           await peerConnection.addIceCandidate(iceCandidate);
        }
        /**
         * To set up a connection
         * @date 8/16/2023 - 3:20:39 PM
         */
        this.call = () => {
            initDataChannel(peerConnection.createDataChannel("chat"));
        }
        /**
         * To hangup the connection
         * @date 8/16/2023 - 3:22:28 PM
         */        
        this.hangUp = () => {
            hangUp();
        }
        /**
         * To get the local description
         * @date 8/16/2023 - 3:16:10 PM
         *
         * @returns {object} the local description
         */
        this.getLocalDescription = () => {
            return peerConnection.localDescription;
        }
        /**
         * To get the RTCPeerConnection signal state
         * @date 8/16/2023 - 3:15:15 PM
         *
         * @returns {string} the RTCPeerConnection signal state
         */
        this.getSignalingState = () => {
            return peerConnection.signalingState;
        }
        /**
         * To initialize the RTCPeerConnection object
         * @date 8/16/2023 - 3:13:33 PM
         */        
        this.init = () => {
            initPeerConnection();
        }
        /**
         * To configure handler for various events
         * @date 8/16/2023 - 3:12:04 PM
         *
         * @param {string} eventType
         * @param {handler} param
         */
        this.on = (eventType, param) => {
            switch (eventType) {
                case "dataChannelClose":
                    dataChannelCloseHandler = param;
                    break;
                case "dataChannelError":
                    dataChannelErrorHandler = param;
                    break;
                case "dataChannelMessage":
                    dataChannelMessageHandler = param;
                    break;
                case "dataChannelOpen":
                    dataChannelOpenHandler = param;
                    break;
                case "iceCandidate":
                    iceCandidateEventHandler = param;
                    break;
                case "iceConnectionStateChange":
                    iceConnectionStateChangeHandler = param;
                    break;
                case "iceGatheringStateChange":
                    iceGatheringStateChangeHandler = param;
                    break;
                case "negotiation":
                    negotiationHandler = param;
                    break;
                case "peerConnectionStateChange":
                    peerConnectionStateChangeHandler = param;
                    break
                case "signalingStateChange":
                    signalingStateChangeHandler = param;
                    break;
                case "stream":
                    trackEventHandler = param;
                    break;
                default: break;
            }
        }
        /**
         * Restart ICE
         * @date 8/16/2023 - 3:36:25 PM
         */        
        this.restartICE = () => {
            if (peerConnection) {
                msgLogger("WebRTC:restart ice.")
                peerConnection.restartIce();
            }
        }
        /**
         *  Send data across the data channel to the remote peer.
         * @date 8/16/2023 - 3:36:59 PM
         *
         * @param {*} data
         */        
        this.send = (data) => {
            if (dataChannel) {
                switch (dataChannel.readyState) {
                    case "open":
                        dataChannel.send(data);
                        break;
                    case "closed":
                    case "closing":
                        if (peerConnection.iceConnectionState === "connected") {
                            initDataChannel(peerConnection.createDataChannel("chat"));
                            dataChannel.send(data);
                        }
                        break;
                    default:
                        break;
                }
            } else {
                throw new Error("The Data Channel is not available.");
            }
        }
        /**
         * Set the Configuration to the RTCPeerConnection object
         * @date 8/16/2023 - 3:37:36 PM
         *
         * @param {object} config
         */        
        this.setConfig = (config) => {
            configuration = { ...config };
        }
        /**
         *  To control if error/debug message is shown  
         * @date 8/16/2023 - 3:38:34 PM
         *
         * @param {boolean} debug
         */        
        this.setDebug = (debug) => {
            isDebug = debug;
        }
        /**
         * To set the local description to the RTCPeerConnection Object  
         * @date 8/16/2023 - 3:39:17 PM
         *
         * @async
         * @returns {*}
         */        
        this.setLocalDescription = async () => {
            await peerConnection.setLocalDescription();
        }
        /**
         * To set the remote description to the RTCPeerConnection Object
         * @date 8/16/2023 - 3:40:09 PM
         *
         * @async
         * @param {*} remoteDescription
         * @returns {*}
         */        
        this.setRemoteDescription = async (remoteDescription) => {
            await peerConnection.setRemoteDescription(remoteDescription);
        }
        /**
         * The local stream setter 
         * @date 8/16/2023 - 3:40:42 PM
         *
         * @param {*} stream
         */        
        this.setStream = (stream) => {
            if (peerConnection) {
                setStream(stream);
            } else {
                localStream = stream;
            }
        }
        /*========================================================================================*/
        /*      Private Method                                                                    */
        /*========================================================================================*/
        /*=====================================================================*/
        /*        Hang Up                                                      */
        /*=====================================================================*/
        let hangUp = () => {
            if (peerConnection &amp;&amp; (peerConnection.signalingState !== "closed")) {
                peerConnection.getSenders().forEach(sender => {
                    peerConnection.removeTrack(sender);
                });
                peerConnection.close();
            }
        }
        /*=====================================================================*/
        /*        Message Logger                                               */
        /*=====================================================================*/
        let msgLogger = (msg) => {
            if (isDebug) {
                console.log(msg);
            }
        }
        /*=====================================================================*/
        /*        Initialize the data channel and its event handler            */
        /*=====================================================================*/
        let initDataChannel = (channel) => {
            dataChannel = channel;
            dataChannel.onclose = () => {
                dataChannelCloseHandler();
            };
            dataChannel.onerror = (event) => {
                dataChannelErrorHandler(event);
            };
            dataChannel.onmessage = (message) => {
                dataChannelMessageHandler(message);
            };
            dataChannel.onopen = () => {
                dataChannelOpenHandler();
            };
        }
        /*=====================================================================*/
        /*        Initialize the peer connection object and its event handler  */
        /*=====================================================================*/
        let initPeerConnection = () => {
            peerConnection = new RTCPeerConnection(configuration);
            peerConnection.ondatachannel = (event) => {
                initDataChannel(event.channel);
            }
            peerConnection.onicecandidate = (event) => {
                iceCandidateEventHandler(event.candidate);
            };
            peerConnection.onconnectionstatechange = () => {
                peerConnectionStateChangeHandler(peerConnection.connectionState);
            }
            peerConnection.oniceconnectionstatechange = () => {
                iceConnectionStateChangeHandler(peerConnection.iceConnectionState);
            };
            peerConnection.onicegatheringstatechange = () => {
                iceGatheringStateChangeHandler(peerConnection.iceGatheringState);
            };
            peerConnection.onnegotiationneeded = async () => {
                await negotiationHandler();
            };
            peerConnection.onsignalingstatechange = () => {
                signalingStateChangeHandler(peerConnection.signalingState);
            };
            peerConnection.ontrack = event => {
                trackEventHandler(event.streams[0]);
            }
            if (localStream) {
                for (const track of localStream.getTracks()) {
                    peerConnection.addTrack(track, localStream);
                }
            }
        }
        /*=====================================================================*/
        /*        Set a stream to the RTCPeerConnection object                 */
        /*=====================================================================*/
        let setStream = (stream) => {
            if (peerConnection) {
                let senders = peerConnection.getSenders();
                senders.forEach(sender => {
                    peerConnection.removeTrack(sender);
                })
                if (stream) {
                    for (const track of stream.getTracks()) {
                        peerConnection.addTrack(track, stream);
                    }
                }
            } else {
                localStream = stream;
            }
        }
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module.exports_module.exports.html">exports</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Wed Aug 16 2023 15:49:23 GMT+0800 (香港標準時間)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
